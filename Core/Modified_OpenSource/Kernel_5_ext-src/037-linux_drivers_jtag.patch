--- ori_linux/drivers/soc/aspeed/aspeed-jtag.c	2021-09-27 22:21:27.545449500 +0800
+++ linux/drivers/soc/aspeed/aspeed-jtag.c	2021-09-27 22:30:37.985456887 +0800
@@ -1,22 +1,10 @@
+// SPDX-License-Identifier: GPL-2.0-or-later
 /*
  * JTAG driver for the Aspeed SoC
  *
- * Copyright (C) ASPEED Technology Inc.
+ * Copyright (C) 2021 ASPEED Technology Inc.
  * Ryan Chen <ryan_chen@aspeedtech.com>
  *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation;
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
  */
 #include <linux/poll.h>
 #include <linux/sysfs.h>
@@ -49,6 +37,7 @@
 #define JTAG_ENG_EN			BIT(31)
 #define JTAG_ENG_OUT_EN			BIT(30)
 #define JTAG_FORCE_TMS			BIT(29)
+
 #define JTAG_IR_UPDATE			BIT(26)		//AST2500 only
 
 #define JTAG_G6_RESET_FIFO		BIT(21)		//AST2600 only
@@ -107,61 +96,68 @@
 
 #define BUFFER_LEN			1024
 #define TCK_FREQ			8000000
-
 /******************************************************************************/
-typedef enum jtag_xfer_mode {
-	HW_MODE = 0,
-	SW_MODE
-} xfer_mode;
-
-struct runtest_idle {
-	xfer_mode	mode;	//0 :HW mode, 1: SW mode
-	unsigned char	reset;	//Test Logic Reset
-	unsigned char	end;	//o: idle, 1: ir pause, 2: drpause
-	unsigned char	tck;	//keep tck
+
+enum jtag_xfer_mode {
+    HW_MODE = 0,
+    SW_MODE,
+};
+
+enum jtag_xfer_type {
+    JTAG_SIR_XFER = 0,
+    JTAG_SDR_XFER = 1,
 };
 
-struct sir_xfer {
-	xfer_mode	mode;	//0 :HW mode, 1: SW mode
-	unsigned short	length;	//bits
-	unsigned int	*tdi;
-	unsigned int	*tdo;
-	unsigned char	endir;	//0: idle, 1:pause
+enum jtag_endstate {
+    JTAG_TLRESET,
+    JTAG_IDLE,
+    JTAG_PAUSEDR,
+    JTAG_PAUSEIR,
+    JTAG_SHIFTDR,
+    JTAG_SHIFTIR
 };
 
-struct sdr_xfer {
-	xfer_mode	mode;	//0 :HW mode, 1: SW mode
-	unsigned char	direct; // 0 ; read , 1 : write
-	unsigned short	length;	//bits
-	unsigned int	*tdio;
-	unsigned char	enddr;	//0: idle, 1:pause
+struct jtag_runtest_idle {
+    enum jtag_xfer_mode mode;
+    enum jtag_endstate end;
+    unsigned int tck;
+};
+
+struct jtag_xfer {
+    enum jtag_xfer_mode mode;
+    enum jtag_xfer_type type;
+    unsigned short length;
+    unsigned int *tdi;
+    unsigned int *tdo;
+    enum jtag_endstate end_sts;
 };
 
 struct io_xfer {
-	xfer_mode	mode;	//0 :HW mode, 1: SW mode
-	unsigned long	Address;
-	unsigned long	Data;
+    enum jtag_xfer_mode mode;
+    unsigned long Address;
+    unsigned long Data;
+	int id; //0:JTAG0 1:JTAG1
 };
 
 struct trst_reset {
-	unsigned long	operation;	// 0 ; read , 1 : write
-	unsigned long	Data;		// 0 means low, 1 means high - TRST pin
+    unsigned long operation;
+    unsigned long Data;
 };
 
-#define JTAGIOC_BASE	'T'
+#define JTAGIOC_BASE 'T'
 
-#define ASPEED_JTAG_IOCRUNTEST	_IOW(JTAGIOC_BASE, 0, struct runtest_idle)
-#define ASPEED_JTAG_IOCSIR	_IOWR(JTAGIOC_BASE, 1, struct sir_xfer)
-#define ASPEED_JTAG_IOCSDR	_IOWR(JTAGIOC_BASE, 2, struct sdr_xfer)
-#define ASPEED_JTAG_SIOCFREQ	_IOW(JTAGIOC_BASE, 3, unsigned int)
-#define ASPEED_JTAG_GIOCFREQ	_IOR(JTAGIOC_BASE, 4, unsigned int)
-#define ASPEED_JTAG_IOWRITE	_IOW(JTAGIOC_BASE, 5, struct io_xfer)
-#define ASPEED_JTAG_IOREAD	_IOR(JTAGIOC_BASE, 6, struct io_xfer)
-#define ASPEED_JTAG_RESET	_IOW(JTAGIOC_BASE, 7, struct io_xfer)
-#define ASPEED_JTAG_TRST_RESET	_IOW(JTAGIOC_BASE, 8, struct trst_reset)
-#define ASPEED_JTAG_RUNTCK	_IOW(JTAGIOC_BASE, 12, struct io_xfer)
+#define ASPEED_JTAG_IOCRUNTEST _IOW(JTAGIOC_BASE, 0, struct jtag_runtest_idle)
+#define ASPEED_JTAG_IOCXFER _IOWR(JTAGIOC_BASE, 1, struct jtag_xfer)
+#define ASPEED_JTAG_SIOCFREQ _IOW(JTAGIOC_BASE, 2, unsigned int)
+#define ASPEED_JTAG_GIOCFREQ _IOR(JTAGIOC_BASE, 3, unsigned int)
+#define ASPEED_JTAG_IOWRITE _IOW(JTAGIOC_BASE, 4, struct io_xfer)
+#define ASPEED_JTAG_IOREAD _IOR(JTAGIOC_BASE, 5, struct io_xfer)
+#define ASPEED_JTAG_RESET _IOW(JTAGIOC_BASE, 6, struct io_xfer)
+#define ASPEED_JTAG_TRST_RESET _IOW(JTAGIOC_BASE, 7, struct trst_reset)
+#define ASPEED_JTAG_RUNTCK _IOW(JTAGIOC_BASE, 8, struct io_xfer)
+//#define ASPEED_JTAG_RUNTCK	_IOW(JTAGIOC_BASE, 12, struct io_xfer)
 /******************************************************************************/
-#define ASPEED_JTAG_DEBUG
+//#define ASPEED_JTAG_DEBUG
 
 #ifdef ASPEED_JTAG_DEBUG
 #define JTAG_DBUG(fmt, args...) printk(KERN_DEBUG "%s() " fmt, __FUNCTION__, ## args)
@@ -179,33 +175,90 @@
 	struct aspeed_jtag_config	*config;
 	u32				*tdi;
 	u32				*tdo;
-	u8				sts;	// 0: idle, 1:irpause 2:drpause
+	enum jtag_endstate		sts;
 	int				irq;	// JTAG IRQ number
 	struct reset_control		*reset;
 	struct clk			*clk;
 	u32				clkin;	// ast2600 use hclk, old use pclk
+	u32				sw_delay; /* unit is ns */
 	u32				flag;
 	wait_queue_head_t		jtag_wq;
 	bool				is_open;
-	struct miscdevice		*misc_dev;
+	struct miscdevice		misc_dev;
+};
+
+/*
+ * This structure represents a TMS cycle, as expressed in a set of bits and a
+ * count of bits (note: there are no start->end state transitions that require
+ * more than 1 byte of TMS cycles)
+ */
+struct tms_cycle {
+	unsigned char		tmsbits;
+	unsigned char		count;
+};
+
+/*
+ * This is the complete set TMS cycles for going from any TAP state to any
+ * other TAP state, following a "shortest path" rule.
+ */
+static const struct tms_cycle _tms_cycle_lookup[][6] = {
+/*	    TLR        RTI        PDR      PIR      SDR      SIR*/
+/* TLR  */{{0x1f, 5}, {0x00, 1}, {0x0a, 5}, {0x16, 6}, {0x02, 4}, {0x06, 5}},
+
+/*	    TLR        RTI        PDR      PIR      SDR      SIR*/
+/* RTI  */{{0x1f, 5}, {0x00, 0}, {0x05, 4}, {0x0b, 5}, {0x01, 3}, {0x03, 4}},
+
+/*	    TLR        RTI        PDR      PIR      SDR      SIR*/
+/* PDR  */{{0x1f, 5}, {0x03, 3}, {0x00, 0}, {0x2f, 7}, {0x01, 2}, {0x0f, 6}},
+
+/*	    TLR        RTI        PDR      PIR      SDR      SIR*/
+/* PIR  */{{0x1f, 5}, {0x03, 3}, {0x17, 6}, {0x00, 0}, {0x07, 5}, {0x01, 2}},
+
+/*	    TLR        RTI        PDR      PIR      SDR      SIR*/
+/* SDR  */{{0x1f, 5}, {0x03, 3}, {0x01, 2}, {0x2f, 7}, {0x00, 0}, {0x0f, 6}},
+
+/*	    TLR        RTI        PDR      PIR      SDR      SIR*/
+/* SIR  */{{0x1f, 5}, {0x03, 3}, {0x17, 6}, {0x01, 2}, {0x07, 5}, {0x00, 0}}
+
 };
 
 /******************************************************************************/
 static DEFINE_SPINLOCK(jtag_state_lock);
+#define JTAG_DEVICE_COUNT 2
+struct aspeed_jtag_info *gJtagTmp[JTAG_DEVICE_COUNT]={NULL,NULL};
+
+static int set_jtag_dev(struct aspeed_jtag_info *pJtag)
+{
+   int i=0;
+   for(i=0;i<JTAG_DEVICE_COUNT;i++)
+   {
+        if(gJtagTmp[i]==NULL)
+        {
+           //printk("i=%d,%s,%p\n",i,pJtag->misc_dev->name,pJtag->reg_base);
+           gJtagTmp[i]=pJtag;
+           break;
+        }
+   }
+
+    return 0;
+}
+
+struct aspeed_jtag_info* get_jtag_dev(int devid)
+{
+     if(devid>=JTAG_DEVICE_COUNT)
+         return NULL;
+
+     return gJtagTmp[devid];
+}
 
 /******************************************************************************/
 static inline u32
 aspeed_jtag_read(struct aspeed_jtag_info *aspeed_jtag, u32 reg)
 {
-#if 0
-	u32 val;
-
+	int val;
 	val = readl(aspeed_jtag->reg_base + reg);
 	JTAG_DBUG("reg = 0x%08x, val = 0x%08x\n", reg, val);
 	return val;
-#else
-	return readl(aspeed_jtag->reg_base + reg);
-#endif
 }
 
 static inline void
@@ -218,196 +271,285 @@
 /******************************************************************************/
 static void aspeed_jtag_set_freq(struct aspeed_jtag_info *aspeed_jtag, unsigned int freq)
 {
-	int div;
+	u32 div;
 
-	for (div = 0; div < JTAG_TCK_DIVISOR_MASK; div++) {
-		if ((aspeed_jtag->clkin / (div + 1)) <= freq)
-			break;
+	/* SW mode frequency setting */
+	aspeed_jtag->sw_delay = DIV_ROUND_UP(NSEC_PER_SEC, freq);
+	JTAG_DBUG("sw mode delay = %d \n", aspeed_jtag->sw_delay);
+	/*
+	 * HW mode frequency setting
+	 * AST2600: TCK period = Period of PCLK * (JTAG14[10:0] + 1)
+	 * AST2500: TCK period = Period of PCLK * (JTAG14[10:0] + 1) * 2
+	 */
+	if (aspeed_jtag->config->jtag_version == 6)
+		div = DIV_ROUND_CLOSEST(aspeed_jtag->clkin, freq);
+	else
+		div = DIV_ROUND_CLOSEST(aspeed_jtag->clkin, freq * 2);
+	if (div >= 1)
+		div = div - 1;
+	if (div > JTAG_TCK_DIVISOR_MASK)
+		div = JTAG_TCK_DIVISOR_MASK;
+	JTAG_DBUG("%d target freq = %d div = %d", aspeed_jtag->clkin, freq,
+		  div);
+	/*
+	 * HW constraint:
+	 * AST2600 minimal TCK divisor = 7 
+	 * AST2500 minimal TCK divisor = 1
+	 */
+	if (aspeed_jtag->config->jtag_version == 6) {
+		if (div < 7)
+			div = 7;
+	} else if (aspeed_jtag->config->jtag_version == 0) {
+		if (div < 1)
+			div = 1;
 	}
 	JTAG_DBUG("set div = %x \n", div);
 
+	/*
+	 * At ast2500: Change clock divider may cause hardware logic confusion.
+	 * Enable software mode to assert the jtag hw logical before change
+	 * clock divider.
+	 */
+	if (aspeed_jtag->config->jtag_version == 0)
+		aspeed_jtag_write(aspeed_jtag,
+				  JTAG_SW_MODE_EN |
+					  aspeed_jtag_read(aspeed_jtag,
+							   ASPEED_JTAG_SW),
+				  ASPEED_JTAG_SW);
 	aspeed_jtag_write(aspeed_jtag, ((aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_TCK) & ~JTAG_TCK_DIVISOR_MASK) | div),  ASPEED_JTAG_TCK);
+	if (aspeed_jtag->config->jtag_version == 0) {
+		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);
+		aspeed_jtag->sts = JTAG_IDLE;
+	}
 }
 
 static unsigned int aspeed_jtag_get_freq(struct aspeed_jtag_info *aspeed_jtag)
 {
-	return aspeed_jtag->clkin / (JTAG_GET_TCK_DIVISOR(aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_TCK)) + 1);
-
+	unsigned int freq;
+	if (aspeed_jtag->config->jtag_version == 6) {
+		/* TCK period = Period of PCLK * (JTAG14[10:0] + 1) */
+		freq = aspeed_jtag->clkin /
+		       (JTAG_GET_TCK_DIVISOR(aspeed_jtag_read(
+				aspeed_jtag, ASPEED_JTAG_TCK)) + 1);
+	} else if (aspeed_jtag->config->jtag_version == 0) {
+		/* TCK period = Period of PCLK * (JTAG14[10:0] + 1) * 2 */
+		freq = (aspeed_jtag->clkin /
+			(JTAG_GET_TCK_DIVISOR(aspeed_jtag_read(
+				 aspeed_jtag, ASPEED_JTAG_TCK)) +1)) >> 1;
+	} else {
+		/* unknown jtag version */
+		freq = 0;
+	}
+	return freq;
 }
 /******************************************************************************/
-static void dummy(struct aspeed_jtag_info *aspeed_jtag, unsigned int cnt)
-{
-	int i = 0;
-
-	for (i = 0; i < cnt; i++)
-		aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW);
-}
-
 static u8 TCK_Cycle(struct aspeed_jtag_info *aspeed_jtag, u8 TMS, u8 TDI)
 {
 	u8 tdo;
 
+	/* IEEE 1149.1
+	 * TMS & TDI shall be sampled by the test logic on the rising edge
+	 * test logic shall change TDO on the falling edge
+	 */
 	// TCK = 0
 	aspeed_jtag_write(aspeed_jtag, JTAG_SW_MODE_EN | (TMS * JTAG_SW_MODE_TMS) | (TDI * JTAG_SW_MODE_TDIO), ASPEED_JTAG_SW);
 
-	dummy(aspeed_jtag, 10);
+	/* Target device have their operating frequency*/
+	ndelay(aspeed_jtag->sw_delay);
 
 	// TCK = 1
 	aspeed_jtag_write(aspeed_jtag, JTAG_SW_MODE_EN | JTAG_SW_MODE_TCK | (TMS * JTAG_SW_MODE_TMS) | (TDI * JTAG_SW_MODE_TDIO), ASPEED_JTAG_SW);
 
+	ndelay(aspeed_jtag->sw_delay);
+	/* Sampled TDI(slave, master's TDO) on the rising edge */
 	if (aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW) & JTAG_SW_MODE_TDIO)
 		tdo = 1;
 	else
 		tdo = 0;
 
-	dummy(aspeed_jtag, 10);
-
-	// TCK = 0
-	aspeed_jtag_write(aspeed_jtag, JTAG_SW_MODE_EN | (TMS * JTAG_SW_MODE_TMS) | (TDI * JTAG_SW_MODE_TDIO), ASPEED_JTAG_SW);
+	JTAG_DBUG("tms: %d tdi: %d tdo: %d", TMS, TDI, tdo);
 
 	return tdo;
 }
 
+static int aspeed_jtag_sw_set_tap_state(struct aspeed_jtag_info *aspeed_jtag,
+				      enum jtag_endstate endstate)
+{
+	int i = 0;
+	enum jtag_endstate from, to;
+
+	if (endstate > JTAG_SHIFTIR)
+		return -EFAULT;
+
+	from = aspeed_jtag->sts;
+	to = endstate;
+	for (i = 0; i < _tms_cycle_lookup[from][to].count; i++)
+		TCK_Cycle(aspeed_jtag,
+			((_tms_cycle_lookup[from][to].tmsbits >> i) & 0x1), 0);
+	aspeed_jtag->sts = endstate;
+	JTAG_DBUG("go to %d", endstate);
+	return 0;
+}
 /******************************************************************************/
 static void aspeed_jtag_wait_instruction_pause_complete(struct aspeed_jtag_info *aspeed_jtag)
 {
-	wait_event_interruptible(aspeed_jtag->jtag_wq, (aspeed_jtag->flag == JTAG_INST_PAUSE));
+	wait_event_interruptible(aspeed_jtag->jtag_wq,
+				 (aspeed_jtag->flag & JTAG_INST_PAUSE));
 	JTAG_DBUG("\n");
-	aspeed_jtag->flag = 0;
+	aspeed_jtag->flag &= ~JTAG_INST_PAUSE;
 }
 
 static void aspeed_jtag_wait_instruction_complete(struct aspeed_jtag_info *aspeed_jtag)
 {
-	wait_event_interruptible(aspeed_jtag->jtag_wq, (aspeed_jtag->flag == JTAG_INST_COMPLETE));
+	wait_event_interruptible(aspeed_jtag->jtag_wq,
+				 (aspeed_jtag->flag & JTAG_INST_COMPLETE));
 	JTAG_DBUG("\n");
-	aspeed_jtag->flag = 0;
+	aspeed_jtag->flag &= ~JTAG_INST_COMPLETE;
 }
 
 static void aspeed_jtag_wait_data_pause_complete(struct aspeed_jtag_info *aspeed_jtag)
 {
-	wait_event_interruptible(aspeed_jtag->jtag_wq, (aspeed_jtag->flag == JTAG_DATA_PAUSE));
+	wait_event_interruptible(aspeed_jtag->jtag_wq,
+				 (aspeed_jtag->flag & JTAG_DATA_PAUSE));
 	JTAG_DBUG("\n");
-	aspeed_jtag->flag = 0;
+	aspeed_jtag->flag &= ~JTAG_DATA_PAUSE;
 }
 
 static void aspeed_jtag_wait_data_complete(struct aspeed_jtag_info *aspeed_jtag)
 {
-	wait_event_interruptible(aspeed_jtag->jtag_wq, (aspeed_jtag->flag == JTAG_DATA_COMPLETE));
+	wait_event_interruptible(aspeed_jtag->jtag_wq,
+				 (aspeed_jtag->flag & JTAG_DATA_COMPLETE));
 	JTAG_DBUG("\n");
-	aspeed_jtag->flag = 0;
+	aspeed_jtag->flag &= ~JTAG_DATA_COMPLETE;
+}
+
+static int aspeed_jtag_run_to_tlr(struct aspeed_jtag_info *aspeed_jtag)
+{
+	if (aspeed_jtag->sts == JTAG_PAUSEIR)
+		aspeed_jtag_write(aspeed_jtag, JTAG_INST_COMPLETE_EN,
+				ASPEED_JTAG_ISR);
+	else if (aspeed_jtag->sts == JTAG_PAUSEDR)
+		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_COMPLETE_EN,
+				ASPEED_JTAG_ISR);
+	aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN | JTAG_FORCE_TMS, ASPEED_JTAG_CTRL);	// x TMS high + 1 TMS low
+	if (aspeed_jtag->sts == JTAG_PAUSEIR)
+		aspeed_jtag_wait_instruction_complete(aspeed_jtag);
+	else if (aspeed_jtag->sts == JTAG_PAUSEDR)
+		aspeed_jtag_wait_data_complete(aspeed_jtag);
+	/* After that the fsm will go to idle state: hw constraint */
+	aspeed_jtag->sts = JTAG_IDLE;
+	return 0;
+}
+
+static int aspeed_jtag_run_to_idle(struct aspeed_jtag_info *aspeed_jtag)
+{
+	if (aspeed_jtag->sts == JTAG_TLRESET) {
+		TCK_Cycle(aspeed_jtag, 0, 0);
+	} else if (aspeed_jtag->sts == JTAG_IDLE) {
+		/* nothing to do */
+	} else if (aspeed_jtag->sts == JTAG_PAUSEDR) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_COMPLETE_EN,
+					  ASPEED_JTAG_ISR);
+		if (aspeed_jtag->config->jtag_version == 6) {
+			aspeed_jtag_write(aspeed_jtag,
+					JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						JTAG_G6_TERMINATE_XFER |
+						JTAG_DATA_EN,
+					ASPEED_JTAG_CTRL);
+		} else {
+			aspeed_jtag_write(aspeed_jtag,
+					  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						  JTAG_TERMINATE_DATA |
+						  JTAG_DATA_EN,
+					  ASPEED_JTAG_CTRL);
+		}
+		aspeed_jtag_wait_data_complete(aspeed_jtag);
+	} else if (aspeed_jtag->sts == JTAG_PAUSEIR) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_INST_COMPLETE_EN,
+					  ASPEED_JTAG_ISR);
+		if (aspeed_jtag->config->jtag_version == 6) {
+			aspeed_jtag_write(aspeed_jtag,
+					JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						JTAG_G6_TERMINATE_XFER |
+						JTAG_G6_INST_EN,
+					ASPEED_JTAG_CTRL);
+		} else {
+			aspeed_jtag_write(aspeed_jtag,
+					JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+						JTAG_TERMINATE_INST |
+						JTAG_INST_EN,
+					ASPEED_JTAG_CTRL);
+		}
+		aspeed_jtag_wait_instruction_complete(aspeed_jtag);
+	} else {
+		pr_err("Should not get here unless aspeed_jtag->sts error!");
+		return -EFAULT;
+	}
+	aspeed_jtag->sts = JTAG_IDLE;
+	return 0;
 }
+
+static int aspeed_jtag_hw_set_tap_state(struct aspeed_jtag_info *aspeed_jtag,
+				      enum jtag_endstate endstate)
+{
+	int ret;
+
+	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW); //dis sw mode
+	mdelay(2);
+	if (endstate == JTAG_TLRESET) {
+		ret = aspeed_jtag_run_to_tlr(aspeed_jtag);
+	} else if (endstate == JTAG_IDLE) {
+		ret = aspeed_jtag_run_to_idle(aspeed_jtag);
+	} else {
+		pr_warn("HW mode not support state %d", endstate);
+		return -EFAULT;
+	}
+	return ret;
+}
+
 /******************************************************************************/
 /* JTAG_reset() is to generate at leaspeed 9 TMS high and
  * 1 TMS low to force devices into Run-Test/Idle State
  */
-static void aspeed_jtag_run_test_idle(struct aspeed_jtag_info *aspeed_jtag, struct runtest_idle *runtest)
+static int aspeed_jtag_run_test_idle(struct aspeed_jtag_info *aspeed_jtag, struct jtag_runtest_idle *runtest)
 {
 	int i = 0;
+	int ret;
 
 	JTAG_DBUG(":%s mode\n", runtest->mode ? "SW" : "HW");
 
 	if (runtest->mode) {
 		// SW mode
-		// from idle , from pause,  -- > to pause, to idle
-		if (runtest->reset) {
-			for (i = 0; i < 10; i++)
-				TCK_Cycle(aspeed_jtag, 1, 0);
-		}
-
-		switch (aspeed_jtag->sts) {
-		case 0:
-			if (runtest->end == 1) {
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to DRSCan
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to IRSCan
-				TCK_Cycle(aspeed_jtag, 0, 0);	// go to IRCap
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to IRExit1
-				TCK_Cycle(aspeed_jtag, 0, 0);	// go to IRPause
-				aspeed_jtag->sts = 1;
-			} else if (runtest->end == 2) {
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to DRSCan
-				TCK_Cycle(aspeed_jtag, 0, 0);	// go to DRCap
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to DRExit1
-				TCK_Cycle(aspeed_jtag, 0, 0);	// go to DRPause
-				aspeed_jtag->sts = 1;
-			} else {
-				TCK_Cycle(aspeed_jtag, 0, 0);	// go to IDLE
-				aspeed_jtag->sts = 0;
-			}
-			break;
-		case 1:
-			//from IR/DR Pause
-			if (runtest->end == 1) {
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to Exit2 IR / DR
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to Update IR /DR
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to DRSCan
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to IRSCan
-				TCK_Cycle(aspeed_jtag, 0, 0);	// go to IRCap
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to IRExit1
-				TCK_Cycle(aspeed_jtag, 0, 0);	// go to IRPause
-				aspeed_jtag->sts = 1;
-			} else if (runtest->end == 2) {
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to Exit2 IR / DR
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to Update IR /DR
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to DRSCan
-				TCK_Cycle(aspeed_jtag, 0, 0);	// go to DRCap
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to DRExit1
-				TCK_Cycle(aspeed_jtag, 0, 0);	// go to DRPause
-				aspeed_jtag->sts = 1;
-			} else {
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to Exit2 IR / DR
-				TCK_Cycle(aspeed_jtag, 1, 0);	// go to Update IR /DR
-				TCK_Cycle(aspeed_jtag, 0, 0);	// go to IDLE
-				aspeed_jtag->sts = 0;
-			}
-			break;
-		default:
-			printk("TODO check ERROR \n");
-			break;
-		}
-
-		for (i = 0; i < runtest->tck; i++)
-			TCK_Cycle(aspeed_jtag, 0, 0);	// stay on IDLE for at lease  TCK cycle
-
+		ret = aspeed_jtag_sw_set_tap_state(aspeed_jtag, runtest->end);
 	} else {
-		aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);  //dis sw mode
-		mdelay(2);
-		if (runtest->reset)
-			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN | JTAG_FORCE_TMS, ASPEED_JTAG_CTRL);	// x TMS high + 1 TMS low
-		else
-			aspeed_jtag_write(aspeed_jtag, JTAG_GO_IDLE, ASPEED_JTAG_IDLE);
-		mdelay(2);
-		aspeed_jtag_write(aspeed_jtag, JTAG_SW_MODE_EN | JTAG_SW_MODE_TDIO, ASPEED_JTAG_SW);
-		aspeed_jtag->sts = 0;
+		ret = aspeed_jtag_hw_set_tap_state(aspeed_jtag, runtest->end);
 	}
+	if (ret)
+		return ret;
+	for (i = 0; i < runtest->tck; i++)
+		TCK_Cycle(aspeed_jtag, 0, 0);
+	return 0;
 }
-
-static void aspeed_sw_jtag_sir_xfer(struct aspeed_jtag_info *aspeed_jtag, struct sir_xfer *sir)
+static void aspeed_sw_jtag_xfer(struct aspeed_jtag_info *aspeed_jtag, struct jtag_xfer *xfer)
 {
 	unsigned int index = 0;
 	u32 shift_bits = 0;
-	u32 tdi = 0;
-	u32 remain_xfer = sir->length;
+	u32 tdi = 0, tdo = 0;
+	u32 remain_xfer = xfer->length;
 
-	if (aspeed_jtag->sts) {
-		//from IR/DR Pause
-		TCK_Cycle(aspeed_jtag, 1, 0);	// go to Exit2 IR / DR
-		TCK_Cycle(aspeed_jtag, 1, 0);	// go to Update IR /DR
-	}
-
-	TCK_Cycle(aspeed_jtag, 1, 0);		// go to DRSCan
-	TCK_Cycle(aspeed_jtag, 1, 0);		// go to IRSCan
-	TCK_Cycle(aspeed_jtag, 0, 0);		// go to IRCap
-	TCK_Cycle(aspeed_jtag, 0, 0);		// go to IRShift
+	if (xfer->type == JTAG_SIR_XFER)
+		aspeed_jtag_sw_set_tap_state(aspeed_jtag, JTAG_SHIFTIR);
+	else
+		aspeed_jtag_sw_set_tap_state(aspeed_jtag, JTAG_SHIFTDR);
 
 	aspeed_jtag->tdo[index] = 0;
 	while (remain_xfer) {
 		tdi = (aspeed_jtag->tdi[index]) >> (shift_bits % 32) & (0x1);
-		if (remain_xfer == 1) {
-			aspeed_jtag->tdo[index] |= TCK_Cycle(aspeed_jtag, 1, tdi);
-		} else {
-			aspeed_jtag->tdo[index] |= TCK_Cycle(aspeed_jtag, 0, tdi);
-			aspeed_jtag->tdo[index] <<= 1;
-		}
+		if (remain_xfer == 1)
+			tdo = TCK_Cycle(aspeed_jtag, 1, tdi); // go to Exit1-IR
+		else
+			tdo = TCK_Cycle(aspeed_jtag, 0, tdi); // go to IRShift
+		aspeed_jtag->tdo[index] |= (tdo << (shift_bits % 32));
 		shift_bits++;
 		remain_xfer--;
 		if ((shift_bits % 32) == 0) {
@@ -415,346 +557,205 @@
 			aspeed_jtag->tdo[index] = 0;
 		}
 	}
-
-	TCK_Cycle(aspeed_jtag, 0, 0);		// go to IRPause
-
-	//stop pause
-	if (sir->endir == 0) {
-		//go to idle
-		TCK_Cycle(aspeed_jtag, 1, 0);		// go to IRExit2
-		TCK_Cycle(aspeed_jtag, 1, 0);		// go to IRUpdate
-		TCK_Cycle(aspeed_jtag, 0, 0);		// go to IDLE
-	}
+	TCK_Cycle(aspeed_jtag, 0, 0);
+	if (xfer->type == JTAG_SIR_XFER)
+		aspeed_jtag->sts = JTAG_PAUSEIR;
+	else
+		aspeed_jtag->sts = JTAG_PAUSEDR;
+	aspeed_jtag_sw_set_tap_state(aspeed_jtag, xfer->end_sts);
 }
 
-static void aspeed_hw_jtag_sir_xfer(struct aspeed_jtag_info *aspeed_jtag, struct sir_xfer *sir)
+static int aspeed_hw_ir_scan(struct aspeed_jtag_info *aspeed_jtag, enum jtag_endstate end_sts, u32 shift_bits)
 {
-	unsigned int index = 0;
-	u32 shift_bits = 0;
-	u32 remain_xfer = sir->length;
-	int i, tmp_idx = 0;
-	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);	//dis sw mode
-
-	while (remain_xfer) {
-		if (remain_xfer > aspeed_jtag->config->jtag_buff_len) {
-			shift_bits = aspeed_jtag->config->jtag_buff_len;
-			tmp_idx = shift_bits / 32;
-			for (i = 0; i < tmp_idx; i++)
-				aspeed_jtag_write(aspeed_jtag, aspeed_jtag->tdi[index + i], ASPEED_JTAG_INST);
-
-			if (aspeed_jtag->config->jtag_version == 6) {
-				aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_G6_SET_XFER_LEN(shift_bits),
-						  ASPEED_JTAG_CTRL);
-				aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_G6_SET_XFER_LEN(shift_bits) |
-						  JTAG_G6_INST_EN, ASPEED_JTAG_CTRL);
-			} else {
-				aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_SET_INST_LEN(shift_bits),
-						  ASPEED_JTAG_CTRL);
-				aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_SET_INST_LEN(shift_bits) |
-						  JTAG_INST_EN, ASPEED_JTAG_CTRL);
-			}
-			aspeed_jtag_wait_instruction_pause_complete(aspeed_jtag);
+	if (end_sts == JTAG_PAUSEIR) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_INST_PAUSE_EN,
+					  ASPEED_JTAG_ISR);
+		if (aspeed_jtag->config->jtag_version == 6) {
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_SET_XFER_LEN(shift_bits),
+					ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_SET_XFER_LEN(shift_bits) |
+					JTAG_G6_INST_EN, ASPEED_JTAG_CTRL);
 		} else {
-			shift_bits = remain_xfer;
-			tmp_idx = shift_bits / 32;
-			if (shift_bits % 32) tmp_idx += 1;
-			for (i = 0; i < tmp_idx; i++)
-				aspeed_jtag_write(aspeed_jtag, aspeed_jtag->tdi[index + i], ASPEED_JTAG_INST);
-
-			if (aspeed_jtag->config->jtag_version == 6) {
-				if (sir->endir) {
-					aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-							  JTAG_G6_SET_XFER_LEN(shift_bits),
-							  ASPEED_JTAG_CTRL);
-					aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-							  JTAG_G6_SET_XFER_LEN(shift_bits) |
-							  JTAG_G6_INST_EN, ASPEED_JTAG_CTRL);
-					aspeed_jtag_wait_instruction_pause_complete(aspeed_jtag);
-				} else {
-					aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-							  JTAG_G6_LAST_XFER | JTAG_G6_SET_XFER_LEN(shift_bits),
-							  ASPEED_JTAG_CTRL);
-					aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-							  JTAG_G6_LAST_XFER | JTAG_G6_SET_XFER_LEN(shift_bits) |
-							  JTAG_G6_INST_EN, ASPEED_JTAG_CTRL);
-					aspeed_jtag_wait_instruction_complete(aspeed_jtag);
-				}
-			} else {
-				if (sir->endir) {
-					aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-							  JTAG_SET_INST_LEN(shift_bits),
-							  ASPEED_JTAG_CTRL);
-					aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-							  JTAG_SET_INST_LEN(shift_bits) |
-							  JTAG_INST_EN, ASPEED_JTAG_CTRL);
-					aspeed_jtag_wait_instruction_pause_complete(aspeed_jtag);
-				} else {
-					aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-							  JTAG_LAST_INST | JTAG_SET_INST_LEN(shift_bits),
-							  ASPEED_JTAG_CTRL);
-					aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-							  JTAG_LAST_INST | JTAG_SET_INST_LEN(shift_bits) |
-							  JTAG_INST_EN, ASPEED_JTAG_CTRL);
-					aspeed_jtag_wait_instruction_complete(aspeed_jtag);
-				}
-			}
+			if (aspeed_jtag->sts == JTAG_PAUSEDR)
+				aspeed_jtag_write(aspeed_jtag,
+						  JTAG_INST_PAUSE_EN |
+							  JTAG_DATA_COMPLETE_EN,
+						  ASPEED_JTAG_ISR);
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_SET_INST_LEN(shift_bits),
+					ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_SET_INST_LEN(shift_bits) |
+					JTAG_INST_EN, ASPEED_JTAG_CTRL);
+			if (aspeed_jtag->sts == JTAG_PAUSEDR)
+				aspeed_jtag_wait_data_complete(aspeed_jtag);
 		}
-
-		remain_xfer = remain_xfer - shift_bits;
-
-		//handle tdo data
-		tmp_idx = shift_bits / 32;
-		if (shift_bits % 32) tmp_idx += 1;
-		for (i = 0; i < tmp_idx; i++) {
-			if (shift_bits < 32)
-				aspeed_jtag->tdo[index + i] = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_INST) >> (32 - shift_bits);
-			else
-				aspeed_jtag->tdo[index + i] = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_INST);
-			shift_bits -= 32;
+		aspeed_jtag_wait_instruction_pause_complete(aspeed_jtag);
+		aspeed_jtag->sts = JTAG_PAUSEIR;
+	} else if (end_sts == JTAG_IDLE) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_INST_COMPLETE_EN,
+					  ASPEED_JTAG_ISR);
+		if (aspeed_jtag->config->jtag_version == 6) {
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_LAST_XFER | JTAG_G6_SET_XFER_LEN(shift_bits),
+					ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_LAST_XFER | JTAG_G6_SET_XFER_LEN(shift_bits) |
+					JTAG_G6_INST_EN, ASPEED_JTAG_CTRL);
+		} else {
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_LAST_INST | JTAG_SET_INST_LEN(shift_bits),
+					ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_LAST_INST | JTAG_SET_INST_LEN(shift_bits) |
+					JTAG_INST_EN, ASPEED_JTAG_CTRL);
 		}
-		index += tmp_idx;
-	}
-
-	// aspeed_jtag->tdo = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_INST);
-
-#if 0
-	aspeed_jtag_write(aspeed_jtag, JTAG_SW_MODE_EN | JTAG_SW_MODE_TDIO, ASPEED_JTAG_SW);
-#else
-	if (sir->endir == 0) {
-		aspeed_jtag_write(aspeed_jtag, JTAG_SW_MODE_EN | JTAG_SW_MODE_TDIO, ASPEED_JTAG_SW);
-	}
-#endif
-
-}
-
-static int aspeed_jtag_sir_xfer(struct aspeed_jtag_info *aspeed_jtag, struct sir_xfer *sir)
-{
-	JTAG_DBUG("%s mode, ENDIR : %d, len : %d \n", sir->mode ? "SW" : "HW", sir->endir, sir->length);
-
-	memset(aspeed_jtag->tdi, 0, BUFFER_LEN * 2);
-
-	if (copy_from_user(aspeed_jtag->tdi, sir->tdi, (sir->length + 7) / 8))
-		return -EFAULT;
-
-	if (sir->mode) {
-		aspeed_sw_jtag_sir_xfer(aspeed_jtag, sir);
+		aspeed_jtag_wait_instruction_complete(aspeed_jtag);
+		aspeed_jtag->sts = JTAG_IDLE;
 	} else {
-		aspeed_hw_jtag_sir_xfer(aspeed_jtag, sir);
-	}
-	aspeed_jtag->sts = sir->endir;
-
-	if (copy_to_user(sir->tdo, aspeed_jtag->tdo, (sir->length + 7) / 8))
+		pr_err("End state %d not support", end_sts);
 		return -EFAULT;
-
+	}
 	return 0;
 }
 
-static void aspeed_sw_jtag_sdr_xfer(struct aspeed_jtag_info *aspeed_jtag, struct sdr_xfer *sdr)
+static int aspeed_hw_dr_scan(struct aspeed_jtag_info *aspeed_jtag, enum jtag_endstate end_sts, u32 shift_bits)
 {
-	unsigned int index = 0;
-	u32 shift_bits = 0;
-	u32 tdo = 0;
-	u32 remain_xfer = sdr->length;
-
-	if (aspeed_jtag->sts) {
-		//from IR/DR Pause
-		TCK_Cycle(aspeed_jtag, 1, 0);		// go to Exit2 IR / DR
-		TCK_Cycle(aspeed_jtag, 1, 0);		// go to Update IR /DR
-	}
-
-	TCK_Cycle(aspeed_jtag, 1, 0);		// go to DRScan
-	TCK_Cycle(aspeed_jtag, 0, 0);		// go to DRCap
-	TCK_Cycle(aspeed_jtag, 0, 0);		// go to DRShift
-
-	if (!sdr->direct)
-		aspeed_jtag->tdo[index] = 0;
-	while (remain_xfer) {
-		if (sdr->direct) {
-			//write
-			if ((shift_bits % 32) == 0)
-				JTAG_DBUG("W dr->dr_data[%d]: %x\n", index, aspeed_jtag->tdo[index]);
-
-			tdo = (aspeed_jtag->tdo[index] >> (shift_bits % 32)) & (0x1);
-			JTAG_DBUG("%d ", tdo);
-			if (remain_xfer == 1) {
-				TCK_Cycle(aspeed_jtag, 1, tdo); // go to DRExit1
-			} else {
-				TCK_Cycle(aspeed_jtag, 0, tdo); // go to DRShit
-			}
+	if (end_sts == JTAG_PAUSEDR) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_PAUSE_EN,
+					  ASPEED_JTAG_ISR);
+		if (aspeed_jtag->config->jtag_version == 6) {
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_SET_XFER_LEN(shift_bits),
+					ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_SET_XFER_LEN(shift_bits) |
+					JTAG_DATA_EN, ASPEED_JTAG_CTRL);
 		} else {
-			//read
-			if (remain_xfer == 1) {
-				tdo = TCK_Cycle(aspeed_jtag, 1, tdo);	// go to DRExit1
-			} else {
-				tdo = TCK_Cycle(aspeed_jtag, 0, tdo);	// go to DRShit
-			}
-			JTAG_DBUG("%d ", tdo);
-			aspeed_jtag->tdo[index] |= (tdo << (shift_bits % 32));
-
-			if ((shift_bits % 32) == 0)
-				JTAG_DBUG("R dr->dr_data[%d]: %x\n", index, aspeed_jtag->tdo[index]);
+			if (aspeed_jtag->sts == JTAG_PAUSEIR)
+				aspeed_jtag_write(aspeed_jtag,
+						  JTAG_DATA_PAUSE_EN |
+							  JTAG_INST_COMPLETE_EN,
+						  ASPEED_JTAG_ISR);
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_DATA_LEN(shift_bits),
+					ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_DATA_LEN(shift_bits) |
+					JTAG_DATA_EN, ASPEED_JTAG_CTRL);
+			if (aspeed_jtag->sts == JTAG_PAUSEIR)
+				aspeed_jtag_wait_instruction_complete(
+					aspeed_jtag);
 		}
-		shift_bits++;
-		remain_xfer--;
-		if ((shift_bits % 32) == 0) {
-			index++;
-			aspeed_jtag->tdo[index] = 0;
+		aspeed_jtag_wait_data_pause_complete(aspeed_jtag);
+		aspeed_jtag->sts = JTAG_PAUSEDR;
+	} else if (end_sts == JTAG_IDLE) {
+		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_COMPLETE_EN,
+					  ASPEED_JTAG_ISR);
+		if (aspeed_jtag->config->jtag_version == 6) {
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_LAST_XFER | JTAG_G6_SET_XFER_LEN(shift_bits),
+					ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_G6_LAST_XFER | JTAG_G6_SET_XFER_LEN(shift_bits) |
+					JTAG_DATA_EN, ASPEED_JTAG_CTRL);
+		} else {
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_LAST_DATA | JTAG_DATA_LEN(shift_bits),
+					ASPEED_JTAG_CTRL);
+			aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
+					JTAG_LAST_DATA | JTAG_DATA_LEN(shift_bits) |
+					JTAG_DATA_EN, ASPEED_JTAG_CTRL);
 		}
-
-	}
-
-	TCK_Cycle(aspeed_jtag, 0, 0);		// go to DRPause
-
-	if (sdr->enddr == 0) {
-		TCK_Cycle(aspeed_jtag, 1, 0);		// go to DRExit2
-		TCK_Cycle(aspeed_jtag, 1, 0);		// go to DRUpdate
-		TCK_Cycle(aspeed_jtag, 0, 0);		// go to IDLE
+		aspeed_jtag_wait_data_complete(aspeed_jtag);
+		aspeed_jtag->sts = JTAG_IDLE;
+	} else {
+		pr_err("End state %d not support", end_sts);
+		return -EFAULT;
 	}
-
+	return 0;
 }
 
-static void aspeed_hw_jtag_sdr_xfer(struct aspeed_jtag_info *aspeed_jtag, struct sdr_xfer *sdr)
+static void aspeed_hw_jtag_xfer(struct aspeed_jtag_info *aspeed_jtag, struct jtag_xfer *xfer)
 {
 	unsigned int index = 0;
 	u32 shift_bits = 0;
-	u32 remain_xfer = sdr->length;
+	u32 remain_xfer = xfer->length;
 	int i, tmp_idx = 0;
+	u32 fifo_reg = xfer->type ? ASPEED_JTAG_DATA : ASPEED_JTAG_INST;
 
-	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW);
+	aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_SW); //dis sw mode
 
 	while (remain_xfer) {
 		if (remain_xfer > aspeed_jtag->config->jtag_buff_len) {
 			shift_bits = aspeed_jtag->config->jtag_buff_len;
 			tmp_idx = shift_bits / 32;
-			for (i = 0; i < tmp_idx; i++) {
-				if (sdr->direct)
-					aspeed_jtag_write(aspeed_jtag, aspeed_jtag->tdo[index + i], ASPEED_JTAG_DATA);
-				else
-					aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_DATA);
-			}
-			// read bytes were not equals to column length ==> Pause-DR
-			JTAG_DBUG("shit bits %d \n", shift_bits);
-			if (aspeed_jtag->config->jtag_version == 6) {
-				aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_G6_SET_XFER_LEN(shift_bits), ASPEED_JTAG_CTRL);
-				aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_G6_SET_XFER_LEN(shift_bits) | JTAG_DATA_EN, ASPEED_JTAG_CTRL);
-			} else {
-				aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_DATA_LEN(shift_bits), ASPEED_JTAG_CTRL);
-				aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-						  JTAG_DATA_LEN(shift_bits) | JTAG_DATA_EN, ASPEED_JTAG_CTRL);
-			}
-			aspeed_jtag_wait_data_pause_complete(aspeed_jtag);
+			for (i = 0; i < tmp_idx; i++)
+				aspeed_jtag_write(aspeed_jtag, aspeed_jtag->tdi[index + i], fifo_reg);
+			if (xfer->type == JTAG_SIR_XFER)
+				aspeed_hw_ir_scan(aspeed_jtag, JTAG_PAUSEIR, shift_bits);
+			else
+				aspeed_hw_dr_scan(aspeed_jtag, JTAG_PAUSEDR, shift_bits);
 		} else {
-			// read bytes equals to column length => Update-DR
 			shift_bits = remain_xfer;
 			tmp_idx = shift_bits / 32;
-			if (shift_bits % 32) tmp_idx += 1;
-			for (i = 0; i < tmp_idx; i++) {
-				if (sdr->direct)
-					aspeed_jtag_write(aspeed_jtag, aspeed_jtag->tdo[index + i], ASPEED_JTAG_DATA);
-				else
-					aspeed_jtag_write(aspeed_jtag, 0, ASPEED_JTAG_DATA);
-			}
-			JTAG_DBUG("shit bits %d with last \n", shift_bits);
-			if (aspeed_jtag->config->jtag_version == 6) {
-				if (sdr->enddr) {
-					JTAG_DBUG("DR Keep Pause \n");
-					aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-							  JTAG_G6_SET_XFER_LEN(shift_bits), ASPEED_JTAG_CTRL);
-					aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-							  JTAG_G6_SET_XFER_LEN(shift_bits) | JTAG_DATA_EN, ASPEED_JTAG_CTRL);
-					aspeed_jtag_wait_data_pause_complete(aspeed_jtag);
-				} else {
-					JTAG_DBUG("DR go IDLE \n");
-					aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN | JTAG_G6_LAST_XFER |
-							  JTAG_G6_SET_XFER_LEN(shift_bits), ASPEED_JTAG_CTRL);
-					aspeed_jtag_write(aspeed_jtag, JTAG_ENG_EN | JTAG_ENG_OUT_EN | JTAG_G6_LAST_XFER |
-							  JTAG_G6_SET_XFER_LEN(shift_bits) | JTAG_DATA_EN, ASPEED_JTAG_CTRL);
-					aspeed_jtag_wait_data_complete(aspeed_jtag);
-				}
-			} else {
-				if (sdr->enddr) {
-					JTAG_DBUG("DR Keep Pause \n");
-					aspeed_jtag_write(aspeed_jtag,
-							  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-							  JTAG_DATA_LEN(shift_bits), ASPEED_JTAG_CTRL);
-					aspeed_jtag_write(aspeed_jtag,
-							  JTAG_ENG_EN | JTAG_ENG_OUT_EN |
-							  JTAG_DATA_LEN(shift_bits) | JTAG_DATA_EN, ASPEED_JTAG_CTRL);
-					aspeed_jtag_wait_data_pause_complete(aspeed_jtag);
-				} else {
-					JTAG_DBUG("DR go IDLE \n");
-					aspeed_jtag_write(aspeed_jtag,
-							  JTAG_ENG_EN | JTAG_ENG_OUT_EN | JTAG_LAST_DATA |
-							  JTAG_DATA_LEN(shift_bits), ASPEED_JTAG_CTRL);
-					aspeed_jtag_write(aspeed_jtag,
-							  JTAG_ENG_EN | JTAG_ENG_OUT_EN | JTAG_LAST_DATA |
-							  JTAG_DATA_LEN(shift_bits) | JTAG_DATA_EN, ASPEED_JTAG_CTRL);
-					aspeed_jtag_wait_data_complete(aspeed_jtag);
-				}
-			}
+			if (shift_bits % 32)
+				tmp_idx += 1;
+			for (i = 0; i < tmp_idx; i++)
+				aspeed_jtag_write(aspeed_jtag, aspeed_jtag->tdi[index + i], fifo_reg);
+			if (xfer->type == JTAG_SIR_XFER)
+				aspeed_hw_ir_scan(aspeed_jtag, xfer->end_sts, shift_bits);
+			else
+				aspeed_hw_dr_scan(aspeed_jtag, xfer->end_sts, shift_bits);
 		}
+
 		remain_xfer = remain_xfer - shift_bits;
+
 		//handle tdo data
-		if (!sdr->direct) {
-			tmp_idx = shift_bits / 32;
-			if (shift_bits % 32) tmp_idx += 1;
-			for (i = 0; i < tmp_idx; i++) {
-				if (shift_bits < 32)
-					aspeed_jtag->tdo[index + i] = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_DATA) >> (32 - shift_bits);
-				else
-					aspeed_jtag->tdo[index + i] = aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_DATA);
-				JTAG_DBUG("R dr->dr_data[%d]: %x\n", index, aspeed_jtag->tdo[index]);
-				shift_bits -= 32;
-			}
+		tmp_idx = shift_bits / 32;
+		if (shift_bits % 32)
+			tmp_idx += 1;
+		for (i = 0; i < tmp_idx; i++) {
+			if (shift_bits < 32)
+				aspeed_jtag->tdo[index + i] = aspeed_jtag_read(aspeed_jtag, fifo_reg) >> (32 - shift_bits);
+			else
+				aspeed_jtag->tdo[index + i] = aspeed_jtag_read(aspeed_jtag, fifo_reg);
+			JTAG_DBUG("TDO[%d]: %x\n", index + i, aspeed_jtag->tdo[index + i]);
+			shift_bits -= 32;
 		}
-
 		index += tmp_idx;
-		JTAG_DBUG("remain_xfer %d\n", remain_xfer);
-	}
-
-#if 0
-	mdelay(2);
-	aspeed_jtag_write(aspeed_jtag, JTAG_SW_MODE_EN | JTAG_SW_MODE_TDIO, ASPEED_JTAG_SW);
-#else
-	if (!sdr->enddr) {
-		mdelay(2);
-		aspeed_jtag_write(aspeed_jtag, JTAG_SW_MODE_EN | JTAG_SW_MODE_TDIO, ASPEED_JTAG_SW);
 	}
-#endif
-
 }
 
-static int aspeed_jtag_sdr_xfer(struct aspeed_jtag_info *aspeed_jtag, struct sdr_xfer *sdr)
+static int aspeed_jtag_xfer(struct aspeed_jtag_info *aspeed_jtag, struct jtag_xfer *xfer)
 {
-
-	JTAG_DBUG("%s mode, len : %d \n", sdr->mode ? "SW" : "HW", sdr->length);
-
+	JTAG_DBUG("%s mode, END : %d, len : %d\n", xfer->mode ? "SW" : "HW", xfer->end_sts, xfer->length);
 	memset(aspeed_jtag->tdi, 0, BUFFER_LEN * 2);
 
-	if (copy_from_user(aspeed_jtag->tdo, sdr->tdio, (sdr->length + 7) / 8))
+	if (copy_from_user(aspeed_jtag->tdi, xfer->tdi, (xfer->length + 7) / 8))
 		return -EFAULT;
 
-	if (sdr->mode) {
-		aspeed_sw_jtag_sdr_xfer(aspeed_jtag, sdr);
-	} else {
-		aspeed_hw_jtag_sdr_xfer(aspeed_jtag, sdr);
-	}
-
-	aspeed_jtag->sts = sdr->enddr;
-
-	if (copy_to_user(sdr->tdio, aspeed_jtag->tdo, (sdr->length + 7) / 8))
+	if (xfer->mode)
+    {
+        aspeed_sw_jtag_xfer(aspeed_jtag, xfer);
+    }
+    else
+    {
+        if(aspeed_jtag->irq<0) 
+        {
+            printk("No irq: %d, JTAG Hardware mode is unavailable",aspeed_jtag->irq);
+            return -EFAULT;
+        }
+
+        aspeed_hw_jtag_xfer(aspeed_jtag, xfer);
+    }
+	if (copy_to_user(xfer->tdo, aspeed_jtag->tdo, (xfer->length + 7) / 8))
 		return -EFAULT;
 
 	return 0;
 }
-
 /*************************************************************************************/
 static irqreturn_t aspeed_jtag_isr(int this_irq, void *dev_id)
 {
@@ -766,29 +767,29 @@
 
 	if (status & JTAG_INST_PAUSE) {
 		aspeed_jtag_write(aspeed_jtag, JTAG_INST_PAUSE | (status & 0xf), ASPEED_JTAG_ISR);
-		aspeed_jtag->flag = JTAG_INST_PAUSE;
+		aspeed_jtag->flag |= JTAG_INST_PAUSE;
 	}
 
 	if (status & JTAG_INST_COMPLETE) {
 		aspeed_jtag_write(aspeed_jtag, JTAG_INST_COMPLETE | (status & 0xf), ASPEED_JTAG_ISR);
-		aspeed_jtag->flag = JTAG_INST_COMPLETE;
+		aspeed_jtag->flag |= JTAG_INST_COMPLETE;
 	}
 
 	if (status & JTAG_DATA_PAUSE) {
 		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_PAUSE | (status & 0xf), ASPEED_JTAG_ISR);
-		aspeed_jtag->flag = JTAG_DATA_PAUSE;
+		aspeed_jtag->flag |= JTAG_DATA_PAUSE;
 	}
 
 	if (status & JTAG_DATA_COMPLETE) {
 		aspeed_jtag_write(aspeed_jtag, JTAG_DATA_COMPLETE | (status & 0xf), ASPEED_JTAG_ISR);
-		aspeed_jtag->flag = JTAG_DATA_COMPLETE;
+		aspeed_jtag->flag |= JTAG_DATA_COMPLETE;
 	}
 
 	if (aspeed_jtag->flag) {
 		wake_up_interruptible(&aspeed_jtag->jtag_wq);
 		return IRQ_HANDLED;
 	} else {
-		printk("TODO Check JTAG's interrupt %x\n", status);
+		pr_err("TODO Check JTAG's interrupt %x\n", aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_ISR));
 		return IRQ_NONE;
 	}
 
@@ -809,31 +810,35 @@
 
 int jtag_write_register(struct io_xfer *io,int size)
 {
-	void __iomem	*reg_add;
-	if(size!=sizeof(struct io_xfer))
-	{
-	    return (-1);
-	}
-
-	reg_add = ioremap(io->Address, 4);
-	writel(io->Data, reg_add);
-	iounmap(reg_add);
-	return 0;
+    struct aspeed_jtag_info *pJtagInfo=NULL;
+    spin_lock(&jtag_state_lock);
+    pJtagInfo=get_jtag_dev(io->id);
+    if(pJtagInfo!=NULL&&pJtagInfo->reg_base!=NULL)
+    {
+       writel(io->Data,(pJtagInfo->reg_base + io->Address));
+    }
+    spin_unlock(&jtag_state_lock);
+	
+	  return 0;
 }
 
-int jtsg_read_register(struct io_xfer *io,int size)
+int jtag_read_register(struct io_xfer *io,int size)
 {
-	void __iomem	*reg_add;
+    struct aspeed_jtag_info *pJtagInfo=NULL;
+    spin_lock(&jtag_state_lock);
+    pJtagInfo=get_jtag_dev(io->id);
+    if(pJtagInfo!=NULL&&pJtagInfo->reg_base!=NULL)
+    {
+       io->Data = readl(pJtagInfo->reg_base + io->Address);
+    }
+    else
+    {
+      spin_unlock(&jtag_state_lock);
+      return (-1);
+    } 
 
-	if(size!=sizeof(struct io_xfer))
-	{
-	    return (-1);
-	}
-	
-	reg_add = ioremap(io->Address, 4);
-	io->Data = readl(reg_add);
-	iounmap(reg_add);
-	return 0;
+    spin_unlock(&jtag_state_lock);
+    return 0;
 }
 
 /*************************************************************************************/
@@ -841,13 +846,12 @@
 		       unsigned long arg)
 {
 	struct miscdevice *c = file->private_data;
-	struct aspeed_jtag_info *aspeed_jtag = dev_get_drvdata(c->this_device);
+	struct aspeed_jtag_info *aspeed_jtag = container_of(c, struct aspeed_jtag_info, misc_dev);
 	void __user *argp = (void __user *)arg;
 	struct io_xfer io;
 	struct trst_reset trst_pin;
-	struct runtest_idle run_idle;
-	struct sir_xfer sir;
-	struct sdr_xfer sdr;
+	struct jtag_runtest_idle run_idle;
+	struct jtag_xfer xfer;
 	int ret = 0;
 
 	switch (cmd) {
@@ -862,28 +866,20 @@
 			aspeed_jtag_set_freq(aspeed_jtag, (unsigned int)arg);
 		break;
 	case ASPEED_JTAG_IOCRUNTEST:
-		if (copy_from_user(&run_idle, argp, sizeof(struct runtest_idle)))
+		if (copy_from_user(&run_idle, argp, sizeof(struct jtag_runtest_idle)))
 			ret = -EFAULT;
 		else
 			aspeed_jtag_run_test_idle(aspeed_jtag, &run_idle);
 		break;
-	case ASPEED_JTAG_IOCSIR:
-		if (copy_from_user(&sir, argp, sizeof(struct sir_xfer)))
+	case ASPEED_JTAG_IOCXFER:
+		if (copy_from_user(&xfer, argp, sizeof(struct jtag_xfer)))
 			return -EFAULT;
-		if (sir.length > 1024)
+		if (xfer.length > 1024)
 			return -EINVAL;
-		ret = aspeed_jtag_sir_xfer(aspeed_jtag, &sir);
-		if (copy_to_user(argp, &sir, sizeof(struct sir_xfer)))
-			return -EFAULT;
-
-		break;
-	case ASPEED_JTAG_IOCSDR:
-		if (copy_from_user(&sdr, argp, sizeof(struct sdr_xfer)))
-			return -EFAULT;
-		if (sdr.length > 1024)
-			return -EFAULT;
-		ret = aspeed_jtag_sdr_xfer(aspeed_jtag, &sdr);
-		if (copy_to_user(argp, &sdr, sizeof(struct sdr_xfer)))
+		ret = aspeed_jtag_xfer(aspeed_jtag, &xfer);
+		if (ret)
+			return ret;
+		if (copy_to_user(argp, &xfer, sizeof(struct jtag_xfer)))
 			return -EFAULT;
 		break;
 	case ASPEED_JTAG_IOWRITE:
@@ -891,6 +887,7 @@
 			ret = -EFAULT;
 		} else {
 			void __iomem	*reg_add;
+
 			reg_add = ioremap(io.Address, 4);
 			writel(io.Data, reg_add);
 			iounmap(reg_add);
@@ -902,6 +899,7 @@
 			ret = -EFAULT;
 		} else {
 			void __iomem	*reg_add;
+
 			reg_add = ioremap(io.Address, 4);
 			io.Data = readl(reg_add);
 			iounmap(reg_add);
@@ -950,7 +948,7 @@
 static int jtag_open(struct inode *inode, struct file *file)
 {
 	struct miscdevice *c = file->private_data;
-	struct aspeed_jtag_info *aspeed_jtag = dev_get_drvdata(c->this_device);
+	struct aspeed_jtag_info *aspeed_jtag = container_of(c, struct aspeed_jtag_info, misc_dev);
 
 	spin_lock(&jtag_state_lock);
 
@@ -969,7 +967,7 @@
 static int jtag_release(struct inode *inode, struct file *file)
 {
 	struct miscdevice *c = file->private_data;
-	struct aspeed_jtag_info *aspeed_jtag = dev_get_drvdata(c->this_device);
+	struct aspeed_jtag_info *aspeed_jtag = container_of(c, struct aspeed_jtag_info, misc_dev);
 
 
 	spin_lock(&jtag_state_lock);
@@ -985,7 +983,6 @@
 			struct device_attribute *attr, char *buf)
 {
 	struct aspeed_jtag_info *aspeed_jtag = dev_get_drvdata(dev);
-
 	return sprintf(buf, "%s\n", aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW) & JTAG_SW_MODE_TDIO ? "1" : "0");
 }
 
@@ -996,7 +993,6 @@
 {
 	u32 tdi;
 	struct aspeed_jtag_info *aspeed_jtag = dev_get_drvdata(dev);
-
 	tdi = simple_strtoul(buf, NULL, 1);
 
 	aspeed_jtag_write(aspeed_jtag, aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW) | JTAG_SW_MODE_EN | (tdi * JTAG_SW_MODE_TDIO), ASPEED_JTAG_SW);
@@ -1011,7 +1007,6 @@
 {
 	u32 tms;
 	struct aspeed_jtag_info *aspeed_jtag = dev_get_drvdata(dev);
-
 	tms = simple_strtoul(buf, NULL, 1);
 
 	aspeed_jtag_write(aspeed_jtag, aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW) | JTAG_SW_MODE_EN | (tms * JTAG_SW_MODE_TMS), ASPEED_JTAG_SW);
@@ -1026,7 +1021,6 @@
 {
 	u32 tck;
 	struct aspeed_jtag_info *aspeed_jtag = dev_get_drvdata(dev);
-
 	tck = simple_strtoul(buf, NULL, 1);
 
 	aspeed_jtag_write(aspeed_jtag, aspeed_jtag_read(aspeed_jtag, ASPEED_JTAG_SW) | JTAG_SW_MODE_EN | (tck * JTAG_SW_MODE_TDIO), ASPEED_JTAG_SW);
@@ -1040,7 +1034,6 @@
 			struct device_attribute *attr, char *buf)
 {
 	struct aspeed_jtag_info *aspeed_jtag = dev_get_drvdata(dev);
-
 	return sprintf(buf, "%s\n", aspeed_jtag->sts ? "Pause" : "Idle");
 }
 
@@ -1060,7 +1053,6 @@
 {
 	u32 val;
 	struct aspeed_jtag_info *aspeed_jtag = dev_get_drvdata(dev);
-
 	val = simple_strtoul(buf, NULL, 20);
 	aspeed_jtag_set_freq(aspeed_jtag, val);
 
@@ -1108,12 +1100,15 @@
 };
 MODULE_DEVICE_TABLE(of, aspeed_jtag_of_matches);
 
+static int reserved_idx = -1;
+
 static int aspeed_jtag_probe(struct platform_device *pdev)
 {
 	struct aspeed_jtag_info *aspeed_jtag;
 	const struct of_device_id *jtag_dev_id;
 	struct resource *res;
-	struct miscdevice *misc_dev;
+	int max_reserved_idx;
+	int idx;
 	int ret = 0;
 
 	JTAG_DBUG("aspeed_jtag_probe\n");
@@ -1140,11 +1135,10 @@
 	}
 
 	aspeed_jtag->irq = platform_get_irq(pdev, 0);
-	if (aspeed_jtag->irq < 0) {
+    printk(KERN_INFO "Using IRQ : %d \n",aspeed_jtag->irq);
+    if (aspeed_jtag->irq < 0) {
 		dev_err(&pdev->dev, "no irq specified\n");
-		ret = -ENOENT;
-		goto out_region;
-	}
+    }
 
 	aspeed_jtag->reset = devm_reset_control_get_exclusive(&pdev->dev, "jtag");
 	if (IS_ERR(aspeed_jtag->reset)) {
@@ -1165,8 +1159,8 @@
 
 	aspeed_jtag->tdi = kmalloc(BUFFER_LEN * 2, GFP_KERNEL);
 	aspeed_jtag->tdo = aspeed_jtag->tdi + (BUFFER_LEN / sizeof(u32));
-
-	JTAG_DBUG("buffer addr : tdi %x tdo %x \n", (u32)aspeed_jtag->tdi, (u32)aspeed_jtag->tdo);
+    aspeed_jtag->sw_delay = 0;
+    JTAG_DBUG("buffer addr : tdi %x tdo %x \n", (u32)aspeed_jtag->tdi, (u32)aspeed_jtag->tdo);
 
 	// SCU init
 	reset_control_assert(aspeed_jtag->reset);
@@ -1183,45 +1177,47 @@
 			  JTAG_SW_MODE_EN | JTAG_SW_MODE_TDIO,
 			  ASPEED_JTAG_SW);
 
-	ret = devm_request_irq(&pdev->dev, aspeed_jtag->irq, aspeed_jtag_isr,
+	if(aspeed_jtag->irq>0)
+    {    
+        ret = devm_request_irq(&pdev->dev, aspeed_jtag->irq, aspeed_jtag_isr,
 			       0, dev_name(&pdev->dev), aspeed_jtag);
-	if (ret) {
-		printk("JTAG Unable to get IRQ");
-		goto out_region;
-	}
+	    if (ret) {
+		    printk("JTAG Unable to get IRQ");
+		    goto out_region;
+	    }
+    }
 
-	// enable interrupt
+	// clear interrupt
 	aspeed_jtag_write(aspeed_jtag,
 			  JTAG_INST_PAUSE | JTAG_INST_COMPLETE |
-			  JTAG_DATA_PAUSE | JTAG_DATA_COMPLETE |
-			  JTAG_INST_PAUSE_EN | JTAG_INST_COMPLETE_EN |
-			  JTAG_DATA_PAUSE_EN | JTAG_DATA_COMPLETE_EN,
+			  JTAG_DATA_PAUSE | JTAG_DATA_COMPLETE,
 			  ASPEED_JTAG_ISR);
 
 	aspeed_jtag->flag = 0;
 	init_waitqueue_head(&aspeed_jtag->jtag_wq);
 
-	misc_dev = (struct miscdevice *)devm_kzalloc(&pdev->dev, sizeof(struct miscdevice), GFP_KERNEL);
-	if (!misc_dev) {
-		pr_err("failed to allocate misc device\n");
-		goto out_irq;
+	if (reserved_idx == -1) {
+		max_reserved_idx = of_alias_get_highest_id("jtag");
+		if (max_reserved_idx >= 0)
+			reserved_idx = max_reserved_idx;
 	}
 
-	misc_dev->minor = MISC_DYNAMIC_MINOR;
-	misc_dev->name = pdev->name;
-	misc_dev->fops = &aspeed_jtag_fops;
+	idx = of_alias_get_id(pdev->dev.of_node, "jtag");;
+	if (idx < 0) {
+		idx = ++reserved_idx;
+	}
 
+	aspeed_jtag->misc_dev.minor = MISC_DYNAMIC_MINOR;
+	aspeed_jtag->misc_dev.name = kasprintf(GFP_KERNEL, "jtag%d", idx);
+	aspeed_jtag->misc_dev.fops = &aspeed_jtag_fops;
 
-	ret = misc_register(misc_dev);
+	ret = misc_register(&aspeed_jtag->misc_dev);
 	if (ret) {
 		printk(KERN_ERR "JTAG : failed to register misc device\n");
 		goto out_irq;
 	}
 
 	platform_set_drvdata(pdev, aspeed_jtag);
-	dev_set_drvdata(misc_dev->this_device, aspeed_jtag);
-
-	aspeed_jtag->misc_dev = misc_dev;
 
 	ret = sysfs_create_group(&pdev->dev.kobj, &jtag_attribute_group);
 	if (ret) {
@@ -1231,43 +1227,45 @@
 
 	aspeed_jtag_set_freq(aspeed_jtag, TCK_FREQ);
 
-	printk(KERN_INFO "aspeed_jtag: driver successfully loaded.\n");
+    set_jtag_dev(aspeed_jtag);
+	printk(KERN_INFO "aspeed_jtag: %s successfully loaded.\n",aspeed_jtag->misc_dev.name);
 
 	return 0;
 
 out_irq:
-	devm_free_irq(&pdev->dev, aspeed_jtag->irq, aspeed_jtag);
+    if(aspeed_jtag->irq>0) devm_free_irq(&pdev->dev, aspeed_jtag->irq, aspeed_jtag);
 out_region:
 	release_mem_region(res->start, res->end - res->start + 1);
 	kfree(aspeed_jtag->tdi);
 out:
-	printk(KERN_WARNING "aspeed_jtag: driver init failed (ret=%d)!\n", ret);
+	printk(KERN_WARNING "aspeed_jtag: %s init failed (ret=%d)!\n", aspeed_jtag->misc_dev.name,ret);
 	return ret;
 }
 
 static int aspeed_jtag_remove(struct platform_device *pdev)
 {
-	struct resource *res;
+	//struct resource *res;
 	struct aspeed_jtag_info *aspeed_jtag = platform_get_drvdata(pdev);
 
 	JTAG_DBUG("aspeed_jtag_remove\n");
 
 	sysfs_remove_group(&pdev->dev.kobj, &jtag_attribute_group);
 
-	misc_deregister(aspeed_jtag->misc_dev);
+	misc_deregister(&aspeed_jtag->misc_dev);
 
-	kfree(aspeed_jtag->misc_dev);
+	kfree_const(aspeed_jtag->misc_dev.name);
 
-	devm_free_irq(&pdev->dev, aspeed_jtag->irq, aspeed_jtag);
+    if(aspeed_jtag->irq>0) devm_free_irq(&pdev->dev, aspeed_jtag->irq, aspeed_jtag);
 
-	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	//res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
 
-	iounmap(aspeed_jtag->reg_base);
+	//iounmap(aspeed_jtag->reg_base);
 
 	platform_set_drvdata(pdev, NULL);
 
-	release_mem_region(res->start, res->end - res->start + 1);
+	//release_mem_region(res->start, res->end - res->start + 1);
 
+    kfree(aspeed_jtag->tdi); 
 	return 0;
 }
 
@@ -1301,7 +1299,7 @@
 module_platform_driver(aspeed_jtag_driver);
 
 EXPORT_SYMBOL(jtag_write_register);
-EXPORT_SYMBOL(jtsg_read_register);
+EXPORT_SYMBOL(jtag_read_register);
 MODULE_AUTHOR("Ryan Chen <ryan_chen@aspeedtech.com>");
 MODULE_DESCRIPTION("AST JTAG LIB Driver");
 MODULE_LICENSE("GPL");
